What is the result of executing the following program? (Choose all that apply.)

import java.util.concurrent.*;
import java.util.concurrent.locks.*;
public class BeachManager {
   private Lock lock = new ReentrantLock();
   public void goSwimming() {
      lock.lock();           // y1
      if (lock.tryLock()) {  // y2
         System.out.println("Swim!");
      }
      lock.unlock();
   }
   public static void main(String[] args) {
      var service = Executors.newFixedThreadPool(2);
      try {
         BeachManager b = new BeachManager();
         for (int i = 0; i ˂ 2; i++)
            service.submit(() -˃ b.goSwimming());
      } finally { service.shutdown(); }
      System.out.print("Tasks Complete");
   } }
A. It prints Swim! at least once.

B. It prints Swim! exactly twice.

C. It prints Tasks Complete.

D. It hangs indefinitely at runtime.

E. The code will not compile because of line y1.

F. The code will not compile because of line y2.

G. It throws an exception at runtime.

Explanation

The application compiles without issue. The most important thing to notice is that the goSwimming() method performs two lock requests, via lock() and tryLock(), but it has only one call to unlock(). For a ReentrantLock, a thread must call unlock() the same number of times it locks the object, or the lock will not be released. Therefore, only one thread is able to acquire the lock and print Swim! at runtime. For these reasons, option A is correct, and option B is incorrect. Option C is also correct, since the lock requests are performed on separate threads from the main() thread. Since the lock is never released by the first thread, the second thread will hang indefinitely, making option D correct.

November 6, 2022 is the weekend that clocks fall back for daylight savings time. What is the output of the following? (Choose two.)

var date = LocalDate.of(2022, Month.NOVEMBER, 6);
var time = LocalTime.of(1, 30);
var zone = ZoneId.of("US/Eastern");
var dateTime1 = ZonedDateTime.of(date, time, zone);
var dateTime2 = dateTime1.plus(1, ChronoUnit.HOURS);

long diff = ChronoUnit.HOURS.between(dateTime1, dateTime2);
int hour = dateTime2.getHour();
boolean offset = dateTime1.getOffset() ==
   dateTime2.getOffset();
System.out.println("diff = " + diff);
System.out.println("hour = " + hour);
System.out.println("offset = " + offset);
A. diff = 0

B. diff = 1

C. hour = 1

D. hour = 2

E. offset = true

F. The code does not compile.

G. A runtime exception is thrown.

Explanation

The dateTime1 variable evaluates to 2016-11-06T01:30-04:00[US/Eastern], and dateTime2 is 2016-11-06T01:30-05:00[US/Eastern]. Option B is correct because it is an hour later. The hours are the same, making option C correct as well. However, the time zone offset changes making it change from 5:30 GMT to 6:30 GMT. Therefore, option E is not correct.

What is the output of the following?

Stream˂String˃ s = Stream.empty();
Stream˂String˃ s2 = Stream.empty();
Predicate˂String˃ condition = b -˃ b.startsWith("c");
Map˂Boolean, List˂String˃˃ p = s.collect(
   Collectors.partitioningBy(condition));
Map˂Boolean, List˂String˃˃ g = s2.collect(
   Collectors.groupingBy(condition));
System.out.println(p + " " + g);
A. {} {}

B. {} {false=[], true=[]}

C. {false=[], true=[]} {}

D. {false=[], true=[]} {false=[], true=[]}

E. The code does not compile.

F. An exception is thrown.

Explanation

This question is really tricky. Did we catch you? The code b -˃ b.startsWith("c") can be passed directly to partitioningBy() or groupingBy(). Java will infer the right type and pass a Predicate to the former and a Function to the latter. However, that’s not what happens in this example. By creating a Predicate variable, the type has to match, the call to groupingBy() does not compile, and option E is the answer.

Which of the following declare immutable classes? (Choose all that apply.)

public final class Frog { boolean poisonous = false; }
public class Toad {
   private final String name;
   private Toad(String name) { this.name = name; }
}

public final class Turtle {}

public final class Snake {
   private final int size = 10;
   void setSize(int size) { size = size; }
   private Snake() {}
}

public class Salamander { private final short color = 10; }
A. Frog

B. Toad

C. Turtle

D. Snake

E. Salamander

F. None of the above

Explanation

Frog is mutable because a class in the same package can modify the poisonous variable. Toad, Turtle, and Snake are immutable because they cannot be extended by another class, declare only private final fields, and don’t expose any mutable objects. Although Snake contains a setSize() method, it does not modify the instance variable. Salamander is mutable because it can be extended by mutable subclass. Options B, C, and D are correct.

What is true of this text block and its output? (Choose all that apply.)

String puzzler = """
   One " \
   Two ""\n
   Three \"\"\"
""";
System.out.print(puzzler);
A. A total of three lines are printed.

B. A total of four lines are printed.

C. One blank line is printed.

D. Two blank lines are printed.

E. Two characters could be removed without changing the result.

F. Three characters could be removed without changing the result.

G. There is essential whitespace.

H. There is incidental whitespace.

Explanation

There is a lot going on here. The output is four lines, making option B one answer. The first line is One " Two "", and the third line is Three """. The second line is blank due to the \n in the code. The fourth line is blank since the text block ends on a new line. Therefore, option D is another correct answer.

The \"\"\" could be written as \""". Since two characters can be removed, option E is an additional answer. Finally, notice that the last line is at the beginning of a line. This means there is only essential whitespace, making option G the final correct answer.

Assuming this program is executed with 20 threads available and without any delays from other threads within the operating system, what is the expected output?

import java.util.concurrent.CopyOnWriteArrayList;
public class Dinosaur {
   private volatile int distance;
   public void stomp() {
      try {
         ++distance;
         Thread.sleep(100 * 1000);
         distance++;
      } catch (InterruptedException e) {}
   }
   private void findBreakfast(int checks) {
      var p = new CopyOnWriteArrayList˂Thread˃();
      for (int i = 0; i ˂ checks; i++)
         p.add(new Thread(this::stomp));
      p.forEach(t -˃ t.start());
      p.forEach(t -˃ t.interrupt());
   }
   public static void main(String[] args) throws Exception {
      var ship = new Dinosaur();
      ship.findBreakfast(10);
      Thread.sleep(10 * 1000);
      System.out.print(ship.distance);
   } }
A. It always prints 10.

B. It always prints 20.

C. It prints a number from 0 to 10 (inclusive).

D. It prints a number from 10 to 20 (inclusive).

E. It does not compile.

F. It compiles but prints an exception at runtime.

G. It compiles but hangs indefinitely at runtime.

The code compiles without issue. At runtime, it starts 10 threads and then interrupts each of them while they are sleeping for 100 seconds. For each thread, the first distance++ is executed, but the second is not. For this reason, the maximum value printed is 10. We say maximum, because the volatile instance variable distance is not thread‐safe. It’s possible the same value could be written twice. For this reason, option C is correct. Note that using CopyOnWriteArrayList over a regular ArrayList has no impact on this program.


Assuming Donkey exists and is serializable and that dataFile refers to a properly serialized file of Donkey objects, what statements about the following code snippet are true? (Choose all that apply.)

10: List˂Donkey˃ readRecords(String dataFile) {
11:    var donkeys = new ArrayList˂Donkey˃();
12:    try (var in = new ObjectInputStream(
13:          new BufferedInputStream(
14:                new FileReader(dataFile)))) {
15:       while (true) {
16:          var d = in.readObject();
17:          if (d instanceof Donkey)
18:             donkeys.add(d);
19:       }
20:    } catch (EOFException e) {
21:    }
22:    return donkeys;
23: }
A. Line 14 does not compile.

B. Line 18 does not compile.

C. Line 20 does not compile.

D. The code contains additional compiler errors.

E. The code compiles but throws an exception at runtime.

F. The code compiles and runs without issue.

Explanation

The code has three bugs that prevent it from compiling. First, line 14 does not compile because BufferedInputStream takes an InputStream, not a Reader, making option A correct. Next, line 18 does not compile because d is not cast to a Donkey before being added to the List, making option B correct. Finally, there are numerous unhandled checked exceptions (IOException, FileNotFoundException, ClassNotFoundException), making option D also correct. One possible fix would be for line 10 to be changed to declare these exceptions.

Incorrect

What is true about a service provider module? (Choose all that apply.)

A. It contains the interface that implementations must provide.

B. It contains exactly one implementation of the interface.

C. It contains one or more implementations of the interface.

D. It can be changed without recompiling any other modules.

E. It must have a provides directive.

F. It must have a uses directive.

Explanation

A service provider interface declares the interface rather than a service provider, making option A incorrect. Each service provider is allowed to provide only one service provider implementation, making option B correct and option C incorrect. One of the benefits of services is being able to change the service provider dynamically, making option D correct. Finally, a service provider interface uses while a service provider provides, making option E correct and option F incorrect.

